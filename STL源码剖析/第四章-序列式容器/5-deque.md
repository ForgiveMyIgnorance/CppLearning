# 1. 概述
## deque与vector的区别
vector是单向开口的连续空间，deque则是一种双向开口的连续空间（头尾两端都可以分别做元素的插入和删除）。
### 区别：
+ 一是deque允许常数时间内对头端进行元素的插入和删除。
+ 二是deque没有容量的观念。
**区别二的解释：**
因为deque是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。
也就是说，像vector那样“因旧空间不足而需要配置一块更大的空间，然后复制元素，在释放旧空间”这样的事在deque是不会发生的。
因此，deque没有必要提供空间保留的功能。
## 缺点
虽然deque也提供Ramdon Access Iterator，但它的迭代器并不是普通指针，其复杂度和vector相比更高。
因此，除非必要，**尽量使用vector而不使用deque。**
对deque的排序操作，为了提高效率，可将deque先完整复制到一个vector身上，将vector排序后（使用STL sort算法），再复制回deque。
# 2. deque的中控器
  deque 是连续空间 (至少逻辑上看来如此)，连续线性空间总令我们联想到array 或 vector。
  array 无法成长，vector 虽可成长，却只能向尾端成长，而且其所谓成长原是个假象，事实上是 (1) 另觅更大空间:(2) 将原数据复制过去;(3)释放原空间三部曲。
  如果不是 vector 每次配置新空间时都有留下一些余裕，其“成长”假象所带来的代价将是相当高昂。
  
  
deque 系由一段一段的定量连续空间构成。
一旦有必要在 deque 的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个 deque 的头端或尾端deque 的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象并提供随机存取的接口。
避开了 “重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构。

受到分段连续线性空间的字面影响，我们可能以为 deque 的实现复杂度和vector 相比虽不中亦不远矣，其实不然。
主要因为，既日分段连续线性空间，就必须有中央控制，而为了维持整体连续的假象，数据结构的设计及迭代器前进后退等操作都颇为繁琐。
deque 的实现代码分量远比 vector 或 list 都多得多。

deque 采用一块所谓的 map (注意，不是 STL 的 map 容器)作为主控。
这里所谓 map 是一小块连续空间，其中每个元素 (此处称为一个节点，node)都是指针，指向另一段 (较大的) 连续线性空间，称为缓冲区。
缓冲区才是 deque 的储存空间主体。
SGI STL 允许我们指定缓冲区大小，默认值 0表示将使用512bytes 缓冲区

# 3. 迭代器
deque 是分段连续空间。维持其“整体连续”假象的任务，落在了迭代器的operator++和 operator-- 两个运算子身上。
迭代器包括：
cur：此迭代器所指之缓冲区中的现行元素
first：此迭代器所指之缓冲区的头
last：此迭代器所指之缓冲区的尾（含备用空间）
node：指向管控空间

# 4. deque的数据结构
## deque的元素
+ map_pointer
+ start
+ finish
+ map_size

## 方法
```C++
begin()
end()
operator[]
front()
back()
size()
max_size()
empty()
```
# 5. deque的元素操作
```C++
pop_back()
pop_front()
clear()
erase()
insert()
```
