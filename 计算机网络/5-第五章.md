# 1 线程池
什么时候需要创建线程池呢？简单的说，如果一个应用需要频繁的创建和销毁线程，而任务执行的时间又非常短，这样线程创建和销毁的带来的开销就不容忽视，这时也是线程池该出场的机会了。如果线程创建和销毁时间相比任务执行时间可以忽略不计，则没有必要使用线程池了。
## 线程池和任务池
主线程负责添加任务，子线程负责执行任务
任务池相当于共享资源, 所以需要使用互斥锁, 当任务池中没有任务的时候需要让线程阻塞, 所以需要使用条件变量
子线程负责从任务池中获取任务，每一个任务有一个回调函数，回调函数执行不同操作

## 相关函数
### （1）线程相关
```c
//创建线程
pthread_create();

//分离属性
pthread_detach();
pthread_attr_t attr;
pthread_attr_init();
pthread_attr_setdetachstate();

//退出线程
pthread_exit();
```
### （2）涉及到共享资源
互斥锁相关函数
```c
pthread_mutex_t mutex;
pthread_mutex_init();
pthread_mutex_lock/unlock();
pthread_mutex_destroy();
```
### （3）能够引起线程阻塞的函数
若线程池已满，主线程应该阻塞等待子线程处理任务；若线程池空了，子线程应该阻塞等待主线程添加任务。
```c
pthread_cond_wait();
pthread_cond_signal();
```

## 代码介绍

```c
#ifndef _THREADPOOL_H
#define _THREADPOOL_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>


typedef struct _PoolTask
{
    int tasknum;//模拟任务编号
    void *arg;//回调函数参数
    void (*task_func)(void *arg);//任务的回调函数
}PoolTask ;

typedef struct _ThreadPool
{
    int max_job_num;//最大任务个数
    int job_num;//实际任务个数
    PoolTask *tasks;//任务队列数组
    int job_push;//入队位置
    int job_pop;// 出队位置

    int thr_num;//线程池内线程个数
    pthread_t *threads;//线程池内线程数组
    int shutdown;//是否关闭线程池
    pthread_mutex_t pool_lock;//线程池的锁
    pthread_cond_t empty_task;//任务队列为空的条件
    pthread_cond_t not_empty_task;//任务队列不为空的条件

}ThreadPool;

void create_threadpool(int thrnum,int maxtasknum);//创建线程池--thrnum  代表线程个数，maxtasknum 最大任务个数
void destroy_threadpool(ThreadPool *pool);//摧毁线程池
void addtask(ThreadPool *pool);//添加任务到线程池
void taskRun(void *arg);//任务回调函数

#endif

```
